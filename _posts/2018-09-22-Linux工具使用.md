---
layout:     post
title:      Linux工具使用
subtitle:   常用的linux命令使用手册
date:       2018-09-22
author:     老张
header-img: img/post-bg-2015.jpg
catalog: true
tags:
    - linux
    - devtoolset
    - strace
    - yum
typora-copy-images-to: ..\img
typora-root-url: ..
---

# 1.strace

------

- **为什么要掌握strace**
- **strace怎么用？**
- **strace问题定位案例**
- **怎么定位进程异常退出**
- **怎么定位共享内存异常**
- **怎么进行性能分析**

## 1.为什么要掌握strace

在程序员及运维人员的日常工作中，故障处理和问题诊断是个主要的工作，也是必备的技能。strace作为一种动态跟踪工具，能够帮助大家高效地定位进程和服务故障。它像是一个侦探，通过系统调用的蛛丝马迹，开启系统调用黑盒，告诉你异常的真相。

> strace底层使用内核的ptrace特性来实现其功能。

strace常用来跟踪进程执行时的系统调用和所接收的信号。 在Linux世界，进程不能直接访问硬件设备，当进程需要访问硬件设备(比如读取磁盘文件，接收网络数据等等)时，必须由用户态模式切换至内核态模式，通 过系统调用访问硬件设备。strace可以跟踪到一个进程产生的系统调用,包括参数，返回值，执行消耗的时间。

> 欢迎关注笔者，优质文章都在这里等你。



## 2.strace怎么用？

既然strace是用来跟踪用户空间进程的系统调用和信号的，在进入strace使用的主题之前，我们的先理解什么是系统调用。

关于系统调用：

> 在计算机中，系统调用**指运行在用户空间的程序向操作系统内核请求需要更高权限运行的服务。**

系统调用提供用户程序与操作系统之间的接口。操作系统的进程空间分为用户空间和内核空间：

- 操作系统内核直接运行在硬件上，提供设备管理、内存管理、任务调度等功能。
- 用户空间通过API请求内核空间的服务来完成其功能——内核提供给用户空间的这些API, 就是系统调用。

在Linux系统上，应用代码通过glibc库封装的函数，间接使用系统调用。

Linux内核目前有300多个系统调用，详细的列表可以通过syscalls手册页查看。这些系统调用主要分为几类：

```
文件和设备访问类 比如open/close/read/write/chmod等
进程管理类 fork/clone/execve/exit/getpid等
信号类 signal/sigaction/kill 等
内存管理 brk/mmap/mlock等
进程间通信IPC shmget/semget * 信号量，共享内存，消息队列等
网络通信 socket/connect/sendto/sendmsg 等
其他
```

熟悉Linux系统调用/系统编程，能够让我们在使用strace时得心应手。不过，对于运维的问题定位来说，知道strace这个工具，会查系统调用手册，就差不多够了。

> 想要深入了解的同学，建议阅读《Linux系统编程》, 《Unix环境高级编程》等书籍。

我们回到strace的使用上来。

### 2.1 strace的两种运行模式。

一种是通过它启动要跟踪的进程。用法很简单，在原本的命令前加上strace即可。比如我们要跟踪 "ls -lh /var/log/messages" 这个命令的执行，可以这样：

```
strace ls -lh /var/log/messages
```

另外一种运行模式，是跟踪已经在运行的进程，在不中断进程执行的情况下，理解它在干嘛。 这种情况，给strace传递个-p pid 选项即可。

比如，有个在运行的some_server服务，第一步，查看pid:

```
pidof some_server 
17553
```

得到其pid 17553然后就可以用strace跟踪其执行:

```
strace -p 17553
```

完成跟踪时，按ctrl + C 结束strace即可。

strace有一些选项可以调整其行为，我们这里介绍下其中几个比较常用的，然后通过示例讲解其实际应用效果。

### 2.2 strace常用选项：

从一个示例命令来看：

```
strace -tt -T -v -f -e trace=file -o /data/log/strace.log -s 1024 -p 23489
-c 统计每一系统调用的所执行的时间,次数和出错的次数等. 
-d 输出strace关于标准错误的调试信息. 
-f 跟踪由fork调用所产生的子进程. 
-ff 如果提供-o filename,则所有进程的跟踪结果输出到相应的filename.pid中,pid是各进程的进程号. 
-F 尝试跟踪vfork调用.在-f时,vfork不被跟踪. 
-h 输出简要的帮助信息. 
-i 输出系统调用的入口指针. 
-q 禁止输出关于脱离的消息. 
-r 打印出相对时间关于,,每一个系统调用. 
-t 在输出中的每一行前加上时间信息. 
-tt 在输出中的每一行前加上时间信息,微秒级. 
-ttt 微秒级输出,以秒了表示时间. 
-T 显示每一调用所耗的时间. 
-v 输出所有的系统调用.一些调用关于环境变量,状态,输入输出等调用由于使用频繁,默认不输出. 
-V 输出strace的版本信息. 
-x 以十六进制形式输出非标准字符串 
-xx 所有字符串以十六进制形式输出.
-o filename 将strace的输出写入文件filename 
-p pid 跟踪指定的进程pid. 
-s strsize 指定输出的字符串的最大长度.默认为32.文件名一直全部输出. 
-u username 以username 的UID和GID执行被跟踪的命令
```

**实例：跟踪nginx, 看其启动时都访问了哪些文件**

```
strace -tt -T -f -e trace=file -o /data/log/strace.log -s 1024 ./nginx
```

部分输出:

输出中，第一列显示的是进程的pid, 接着是毫秒级别的时间，这个是-tt 选项的效果。

每一行的最后一列，显示了该调用所花的时间，是-T选项的结果。

这里的输出只显示和文件访问有关的内容，这是因为我们通过-e trace=file 选项指定了。





## 3. strace问题定位案例

### 3.1.定位进程异常退出

问题：机器上有个叫做run.sh的常驻脚本，运行一分钟后会死掉。需要查出死因。

定位：进程还在运行时，通过ps命令获取其pid, 假设我们得到的pid是24298

```
strace -o strace.log -tt -p 24298
```

查看strace.log, 我们在最后2行看到如下内容:

```
22:47:42.803937 wait4(-1, <unfinished ...>
22:47:43.228422 +++ killed by SIGKILL +++
```

这里可以看出，进程是被其他进程用KILL信号杀死的。

实际上，通过分析，我们发现机器上别的服务有个监控脚本，它监控一个也叫做run.sh的进程，当发现run.sh进程数大于2时，就会把它杀死重启。结果导致我们这个run.sh脚本被误杀。

进程被杀退出时，strace会输出killed by SIGX(SIGX代表发送给进程的信号)等，那么，进程自己退出时会输出什么呢？

这里有个叫做test_exit的程序，其代码如下:

```
#include <stdio.h>
#include <stdlib.h>
int main(int argc, char **argv) {
 exit(1);
}
```

我们strace看下它退出时strace上能看到什么痕迹。

```
strace -tt -e trace=process -f ./test_exit
```

说明: -e trace=process 表示只跟踪和进程管理相关的系统调用。

输出：

```
23:07:24.672849 execve("./test_exit", ["./test_exit"], [/* 35 vars */]) = 0
23:07:24.674665 arch_prctl(ARCH_SET_FS, 0x7f1c0eca7740) = 0
23:07:24.675108 exit_group(1) = ?
23:07:24.675259 +++ exited with 1 +++
```

可以看出，进程自己退出时（调用exit函数，或者从main函数返回）, 最终调用的是exit_group系统调用， 并且strace会输出exited with X（X为退出码）。

可能有人会疑惑，代码里面明明调用的是exit, 怎么显示为exit_group?

> 这是因为这里的exit函数不是系统调用，而是glibc库提供的一个函数，exit函数的调用最终会转化为exit_group系统调用，它会退出当前进程的所有线程。实际上，有一个叫做_exit()的系统调用(注意exit前面的下划线), 线程退出时最终会调用它。

### 3.2.定位共享内存异常

有个服务启动时报错：

```
shmget 267264 30097568: Invalid argument
Can not get shm...exit!
```

错误日志大概告诉我们是获取共享内存出错，通过strace看下：

```
strace -tt -f -e trace=ipc ./a_mon_svr ../conf/a_mon_svr.conf
```

输出：

```
22:46:36.351798 shmget(0x5feb, 12000, 0666) = 0
22:46:36.351939 shmat(0, 0, 0) = ?
Process 21406 attached
22:46:36.355439 shmget(0x41400, 30097568, 0666) = -1 EINVAL (Invalid argument)
shmget 267264 30097568: Invalid argument
Can not get shm...exit!
```

这里，我们通过-e trace=ipc 选项，让strace只跟踪和进程通信相关的系统调用。

从strace输出，我们知道是shmget系统调用出错了，errno是EINVAL。同样， 查询下shmget手册页，搜索EINVAL的错误码的说明:

> EINVAL A new segment was to be created and size < SHMMIN or size > SHMMAX, or no new segment was to be created, a segment with given key existed, but size is greater than the size of that segment

翻译下，shmget设置EINVAL错误码的原因为下列之一：

- 要创建的共享内存段比 SHMMIN小 (一般是1个字节)
- 要创建的共享内存段比 SHMMAX 大 (内核参数kernel.shmmax配置)
- 指定key的共享内存段已存在，其大小和调用shmget时传递的值不同。

从strace输出看，我们要连的共享内存key 0x41400, 指定的大小是30097568字节，明显与第1、2种情况不匹配。那只剩下第三种情况。使用ipcs看下是否真的是大小不匹配：

```
ipcs -m | grep 41400
key shmid owner perms bytes nattch status 
0x00041400 1015822 root 666 30095516 1
```

可以看到，已经0x41400这个key已经存在，并且其大小为30095516字节，和我们调用参数中的30097568不匹配，于是产生了这个错误。

在我们这个案例里面，导致共享内存大小不一致的原因，是一组程序中，其中一个编译为32位，另外一个编译为64位,代码里面使用了long这个变长int数据类型。

> 把两个程序都编译为64解决了这个问题。

**这里特别说下strace的-e trace选项。**

要跟踪某个具体的系统调用，-e trace=xxx即可。但有时候我们要跟踪一类系统调用，比如所有和文件名有关的调用、所有和内存分配有关的调用。

如果人工输入每一个具体的系统调用名称，可能容易遗漏。于是strace提供了几类常用的系统调用组合名字。

> -e trace=file 跟踪和文件访问相关的调用(参数中有文件名)
>
> -e trace=process 和进程管理相关的调用，比如fork/exec/exit_group
>
> -e trace=network 和网络通信相关的调用，比如socket/sendto/connect
>
> -e trace=signal 信号发送和处理相关，比如kill/sigaction
>
> -e trace=desc 和文件描述符相关，比如write/read/select/epoll等
>
> -e trace=ipc 进程见同学相关，比如shmget等

绝大多数情况，我们使用上面的组合名字就够了。实在需要跟踪具体的系统调用时，可能需要注意C库实现的差异。

> 比如我们知道创建进程用的是fork系统调用，但在glibc里面，fork的调用实际上映射到了更底层的clone系统调用。使用strace时，得指定-e trace=clone, 指定-e trace=fork什么也匹配不上。

### 3.3性能分析

假如有个需求，统计Linux 4.5.4 版本内核中的代码行数(包含汇编和C代码)。这里提供两个Shell脚本实现：

poor_script.sh:

> !/bin/bash
>
> total_line=0
>
> while read filename; do
>
> line=$(wc -l $filename | awk ‘{print $1}’)
>
> (( total_line += line ))
>
> done < <( find linux-4.5.4 -type f ( -iname ‘*.c’ -o -iname ‘*.h’ -o -iname ‘*.S’ ) )
>
> echo “total line: $total_line”

good_script.sh:

> !/bin/bash
>
> find linux-4.5.4 -type f ( -iname ‘*.c’ -o -iname ‘*.h’ -o -iname ‘*.S’ ) -print0
>
> | wc -l —files0-from - | tail -n 1

两段代码实现的目的是一样的。 我们通过strace的-c选项来分别统计两种版本的系统调用情况和其所花的时间(使用-f同时统计子进程的情况)

从两个输出可以看出，good_script.sh 只需要2秒就可以得到结果：19613114行。它大部分的调用(calls)开销是文件操作(read/open/write/close)等，统计代码行数本来就是干这些事情。

而poor_script.sh完成同样的任务则花了539秒。它大部分的调用开销都在进程和内存管理上(wait4/mmap/getpid…)。

实际上，从两个图中clone系统调用的次数,我们可以看出good_script.sh只需要启动3个进程，而poor_script.sh完成整个任务居然启动了126335个进程！

> 而进程创建和销毁的代价是相当高的，所以性能受到影响。



### 3.4 解决库依赖问题

starce 的另一个用处是解决和动态库相关的问题。当对一个可执行文件运行ldd时，它会告诉你程序使用的动态库和找到动态库的位置。但是如果你正在使用一个比较老 的glibc版本（2.2或更早），你可能会有一个有bug的ldd程序，它可能会报告在一个目录下发现一个动态库，但是真正运行程序时动态连接程序 （/lib/ld-linux.so.2）却可能到另外一个目录去找动态连接库。这通常因为/etc/ld.so.conf和 /etc/ld.so.cache文件不一致，或者/etc/ld.so.cache被破坏。在glibc 2.3.2版本上这个错误不会出现，可能ld-linux的这个bug已经被解决了。

尽管这样，ldd并不能把所有程序依赖的动态库列出 来，系统调用dlopen可以在需要的时候自动调入需要的动态库，而这些库可能不会被ldd列出来。作为glibc的一部分的NSS（Name Server Switch）库就是一个典型的例子，NSS的一个作用就是告诉应用程序到哪里去寻找系统帐号数据库。应用程序不会直接连接到NSS库，glibc则会通 过dlopen自动调入NSS库。如果这样的库偶然丢失，你不会被告知存在库依赖问题，但这样的程序就无法通过用户名解析得到用户ID了。让我们看一个例子：

whoami程序会给出你自己的用户名，这个程序在一些需要知道运行程序的真正用户的脚本程序里面非常有用，whoami的一个示例 输出如下：

\# whoam

iroot

假设因为某种原因在升 级glibc的过程中负责用户名和用户ID转换的库NSS丢失，我们可以通过把nss库改名来模拟这个环境：

\# mv /lib/libnss_files.so.2 /lib/libnss_files.so.2.backup 
\# whoami
whoami: cannot find username for UID 0

这里你可以看到，运行whoami时出现了错误，ldd程序的输出不会提供有用的帮助：

\# ldd /usr/bin/whoami
libc.so.6 => /lib/libc.so.6 (0x4001f000)
/lib/ld-linux.so.2 => /lib/ld-linux.so.2 (0x40000000)

你只会看到whoami依赖Libc.so.6和ld-linux.so.2，它没有给出运行whoami所必须的其他库。这里时用strace跟踪 whoami时的输出：

strace -o whoami-strace.txt whoami

open("/lib/libnss_files.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
open("/lib/i686/mmx/libnss_files.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
stat64("/lib/i686/mmx", 0xbffff190) = -1 ENOENT (No such file or directory) 
open("/lib/i686/libnss_files.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
stat64("/lib/i686", 0xbffff190) = -1 ENOENT (No such file or directory)
open("/lib/mmx/libnss_files.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
stat64("/lib/mmx", 0xbffff190) = -1 ENOENT (No such file or directory) 
open("/lib/libnss_files.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
stat64("/lib", {st_mode=S_IFDIR|0755, st_size=2352, ...}) = 0
open("/usr/lib/i686/mmx/libnss_files.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)
stat64("/usr/lib/i686/mmx", 0xbffff190) = -1 ENOENT (No such file or directory) 
open("/usr/lib/i686/libnss_files.so.2", O_RDONLY) = -1 ENOENT (No such file or directory)

你可以发现在不同目录下面查找libnss.so.2的尝试，但是都失败了。如果没有strace这样的工具，很难发现这个错误是由于缺少动态库造成的。现 在只需要找到libnss.so.2并把它放回到正确的位置就可以了。　

## 4.总结

当发现进程或服务异常时，我们可以通过strace来跟踪其系统调用，“看看它在干啥”，进而找到异常的原因。熟悉常用系统调用，能够更好地理解和使用strace。

当然，万能的strace也不是真正的万能。当目标进程卡死在用户态时，strace就没有输出了。

这个时候我们需要其他的跟踪手段，比如gdb/perf/SystemTap等，后续的文章我们也会对这些命令进行详细解读。

> 参考文章:https://www.linuxidc.com/Linux/2018-01/150654.htm



# 2.tcpdump

------

## 1.命令行选项

```
tcpdump [ -DenNqvX ] [ -c count ] [ -F file ] [ -i interface ] [ -r file ]
        [ -s snaplen ] [ -w file ] [ expression ]

抓包选项：
-c：指定要抓取的包数量。注意，是最终要获取这么多个包。例如，指定"-c 10"将获取10个包，但可能已经处理了100个包，只不过只有10个包是满足条件的包。
-i interface：指定tcpdump需要监听的接口。若未指定该选项，将从系统接口列表中搜寻编号最小的已配置好的接口(不包括loopback接口，要抓取loopback接口使用tcpdump -i lo)，
            ：一旦找到第一个符合条件的接口，搜寻马上结束。可以使用'any'关键字表示所有网络接口。
-n：对地址以数字方式显式，否则显式为主机名，也就是说-n选项不做主机名解析。
-nn：除了-n的作用外，还把端口显示为数值，否则显示端口服务名。
-N：不打印出host的域名部分。例如tcpdump将会打印'nic'而不是'nic.ddn.mil'。
-P：指定要抓取的包是流入还是流出的包。可以给定的值为"in"、"out"和"inout"，默认为"inout"。
-s len：设置tcpdump的数据包抓取长度为len，如果不设置默认将会是65535字节。对于要抓取的数据包较大时，长度设置不够可能会产生包截断，若出现包截断，
      ：输出行中会出现"[|proto]"的标志(proto实际会显示为协议名)。但是抓取len越长，包的处理时间越长，并且会减少tcpdump可缓存的数据包的数量，
      ：从而会导致数据包的丢失，所以在能抓取我们想要的包的前提下，抓取长度越小越好。

输出选项：
-e：输出的每行中都将包括数据链路层头部信息，例如源MAC和目标MAC。
-q：快速打印输出。即打印很少的协议相关信息，从而输出行都比较简短。
-X：输出包的头部数据，会以16进制和ASCII两种方式同时输出。
-XX：输出包的头部数据，会以16进制和ASCII两种方式同时输出，更详细。
-v：当分析和打印的时候，产生详细的输出。
-vv：产生比-v更详细的输出。
-vvv：产生比-vv更详细的输出。

其他功能性选项：
-D：列出可用于抓包的接口。将会列出接口的数值编号和接口名，它们都可以用于"-i"后。
-F：从文件中读取抓包的表达式。若使用该选项，则命令行中给定的其他表达式都将失效。
-w：将抓包数据输出到文件中而不是标准输出。可以同时配合"-G time"选项使得输出文件每time秒就自动切换到另一个文件。可通过"-r"选项载入这些文件以进行分析和打印。
-r：从给定的数据包文件中读取数据。使用"-"表示从标准输入中读取。

Here are some additional ways to tweak how you call tcpdump.

-X : Show the packet’s contents in both hex and ascii.
-XX : Same as -X, but also shows the ethernet header.
-D : Show the list of available interfaces
-l : Line-readable output (for viewing as you save, or sending to other commands)
-q : Be less verbose (more quiet) with your output.
-t : Give human-readable timestamp output.
-tttt : Give maximally human-readable timestamp output.
-i eth0 : Listen on the eth0 interface.
-vv : Verbose output (more v’s gives more output).
-c : Only get x number of packets and then stop.
-s : Define the snaplength (size) of the capture in bytes. Use -s0 to get everything, unless you are intentionally capturing less.
-S : Print absolute sequence numbers.
-e : Get the ethernet header as well.
-q : Show less protocol information.
-E : Decrypt IPSEC traffic by providing an encryption key.
```

所以常用的选项也就这几个：

- ```
  tcpdump -D
  tcpdump -c num -i int -nn -XX -vvv
  ```



## 2. tcpdump表达式

表达式用于筛选输出哪些类型的数据包，如果没有给定表达式，所有的数据包都将输出，否则只输出表达式为true的包。在表达式中出现的shell元字符建议使用单引号包围。

tcpdump的表达式由一个或多个"单元"组成，每个单元一般包含ID的修饰符和一个ID(数字或名称)。有三种修饰符：

(1).type：指定ID的类型。

可以给定的值有host/net/port/portrange。例如"host foo"，"net 128.3"，"port 20"，"portrange 6000-6008"。默认的type为host。

(2).dir：指定ID的方向。

可以给定的值包括src/dst/src or dst/src and dst，默认为src or dst。例如，"src foo"表示源主机为foo的数据包，"dst net 128.3"表示目标网络为128.3的数据包，"src or dst port 22"表示源或目的端口为22的数据包。

(3).proto：通过给定协议限定匹配的数据包类型。

常用的协议有tcp/udp/arp/ip/ether/icmp等，若未给定协议类型，则匹配所有可能的类型。例如"tcp port 21"，"udp portrange 7000-7009"。

所以，一个基本的表达式单元格式为"proto dir type ID"

![img](img/tcpdump-expression.png)

除了使用修饰符和ID组成的表达式单元，还有关键字表达式单元：gateway，broadcast，less，greater以及算术表达式。

表达式单元之间可以使用操作符" and / && / or / || / not / ! "进行连接，从而组成复杂的条件表达式。如"host foo and not port ftp and not port ftp-data"，这表示筛选的数据包要满足"主机为foo且端口不是ftp(端口21)和ftp-data(端口20)的包"，常用端口和名字的对应关系可在linux系统中的/etc/service文件中找到。

另外，同样的修饰符可省略，如"tcp dst port ftp or ftp-data or domain"与"tcp dst port ftp or tcp dst port ftp-data or tcp dst port domain"意义相同，都表示包的协议为tcp且目的端口为ftp或ftp-data或domain(端口53)。



> 这里 ftp、ftp-data到底对应哪个端口？ linux系统下 /etc/services这个文件里面，就存储着所有知名服务和传输层端口的对应关系。如果你直接把/etc/services里的ftp对应的端口值从21改为了3333，那么tcpdump就会去抓端口含有3333的网络包了。



使用括号"()"可以改变表达式的优先级，但需要注意的是括号会被shell解释，所以应该使用反斜线"\"转义为"\(\)"，在需要的时候，还需要包围在引号中。

> It’s All About the Combinations
>
> Being able to do these various things individually is powerful, but the real magic of `tcpdump` comes from the ability to **combine options in creative ways** in order to isolate exactly what you’re looking for. There are three ways to do combinations, and if you’ve studied programming at all they’ll be pretty familiar to you.
>
> 1. **AND** 
>    *and* or `&&`
> 2. **OR** 
>    *or* or `||`
> 3. **EXCEPT** 
>    *not* or `!`



下面介绍一些tcpdump中过滤语句比较高级的用法

比如想获取172.16.10.11和google.com之间建立TCP三次握手中带有SYN标记位的网络包.

命令为：sudo tcpdump -i eth0 'host 172.16.0.11 andhost google.com and tcp[tcpflags]&tcp-syn!=0' -c 3 -nn

![img](/img/20150203100851128)



上面的命令是不是看着有点晕的感觉。    是的。

下面详细介相关知识。

其实我们理解这种语法:  proto [ expr : size] ，就不难理解上面的语句了。

下面详细介绍proto [ expr : size]

Proto即protocol的缩写，它表示这里要指定的是某种协议名称，如ip,tcp,udp等。总之可以指定的协议有十多种，如链路层协议 ether,fddi,tr,wlan,ppp,slip,link,

网络层协议ip,ip6,arp,rarp,icmp传输层协议tcp,udp等。

expr用来指定数据报字节单位的偏移量，该偏移量相对于指定的协议层，默认的起始位置是0；而size表示从偏移量的位置开始提取多少个字节，可以设置为

1、2、4,默认为1字节。如果只设置了expr，而没有设置size，则默认提取1个字节。比如ip[2:2]，就表示提取出第3、4个字节；而ip[0]则表示提取ip协议头的

第一个字节。在我们提取了特定内容之后，我们就需要设置我们的过滤条件了，我们可用的“比较操作符”包括：>，<，>=，<=，=，!=，总共有6个。

举例：想截取每个TCP会话的起始和结束报文(SYN 和 FIN 报文), 而且会话方中有一个远程主机.

sudo tcpdump 'tcp[13] & 3 != 0 and not(src and dst net 172.16.0.0)' -nn

如果熟悉tcp首部报文格式可以比较容易理解这句话，因为tcp便宜13字节的位置为2位保留位和6位标志位(URG,ACK,PSH,RST,SYN,FIN), 所以与3相与就可以得出

SYN,FIN其中是否一个置位1. 

从上面可以看到在写过滤表达式时，需要我们对协议格式比较理解才能把表达式写对。这个比较有难度的..。为了让tcpdump工具更人性化一些，有一些常用的偏移量，

可以通过一些名称来代替，比如icmptype表示ICMP协议的类型域、icmpcode表示ICMP的code域，tcpflags 则表示TCP协议的标志字段域。

更进一步的，对于ICMP的类型域，可以用这些名称具体指代：icmp-echoreply, icmp-unreach, icmp-sourcequench, icmp-redirect,icmp-echo, icmp-routeradvert, icmp-routersolicit, icmp-timxceed, icmp-paramprob,icmp-tstamp, icmp-tstampreply, icmp-ireq, icmp-ireqreply, icmp-maskreq,icmp-maskreply。

而对于TCP协议的标志字段域，则可以细分为tcp-fin, tcp-syn, tcp-rst, tcp-push, tcp-ack, tcp-urg。

对于tcpdump 只能通过经常操作来熟练这些语句了。也可以把网络包用tcpdump截获保存到指定文件,然后用wireshark等可视化软件分析网络包。



## 3.使用例子

- #### 1. Display Available Interfaces

To list number of available interfaces on the system, run the following command with **-D** option.

```bash
# tcpdump -D
```

- ####  **监视指定网络接口的数据包**

```
 tcpdump -i eth0
```

- ####  Capture Only N Number of Packets

When you run **tcpdump** command it will capture all the packets for specified interface, until you **Hit** cancel button. But using **-c** option, you can capture specified number of packets. The below example will only capture **6**packets.

```
# tcpdump -c 5 -i eth0
```

- ####  Display Captured Packets in HEX and ASCII

The following command with option **-XX** capture the data of each packet, including its link level header in **HEX**and **ASCII** format.

```
# tcpdump -XX -i eth0
```

- ####  Capture and Save Packets in a File

As we said, that **tcpdump** has a feature to capture and save the file in a **.pcap** format, to do this just execute command with **-w** option.

```
# tcpdump -w 0001.pcap -i eth0
```

- ####  Read Captured Packets File

To read and analyze captured packet **0001.pcap** file use the command with **-r** option, as shown below.

```
# tcpdump -r 0001.pcap
```

- #### 7. Capture IP address Packets

To capture packets for a specific interface, run the following command with option **-n**.

```
# tcpdump -n -i eth0
```

- ####  Capture only TCP Packets.

To capture packets based on **TCP** port, run the following command with option **tcp**.

```
# tcpdump -i eth0 tcp
```

- #### 9. Capture Packet from Specific Port

Let’s say you want to capture packets for specific port 22, execute the below command by specifying port number **22** as shown below.

```
# tcpdump -i eth0 port 22
```

- #### 10. Capture Packets from source IP

To capture packets from source **IP**, say you want to capture packets for **192.168.0.2**, use the command as follows.

```
# tcpdump -i eth0 src 192.168.0.2
```

- ####  Capture Packets from destination IP

To capture packets from destination **IP**, say you want to capture packets for **50.116.66.139**, use the command as follows.

```
# tcpdump -i eth0 dst 50.116.66.139
```

- **监视指定主机的数据包，例如所有进入或离开longshuai的数据包**

```
tcpdump host longshuai
```

- **打印helios<-->hot或helios<-->ace之间通信的数据包**

```
tcpdump host helios and \( hot or ace \)
```

- **打印ace与任何其他主机之间通信的IP数据包,但不包括与helios之间的数据包**

```
tcpdump ip host ace and not helios
```

- **截获主机hostname发送的所有数据**

```
tcpdump src host hostname
```

- **监视所有发送到主机hostname的数据包**

```
tcpdump dst host hostname
```

- **监视指定主机和端口的数据包**

```
tcpdump tcp port 22 and host hostname
```

- **对本机的udp 123端口进行监视(123为ntp的服务端口)**

```
tcpdump udp port 123
```

- **监视指定网络的数据包，如本机与192.168网段通信的数据包，"-c 10"表示只抓取10个包**

```
tcpdump -c 10 net 192.168
```

- **打印所有通过网关snup的ftp数据包(注意,表达式被单引号括起来了,这可以防止shell对其中的括号进行错误解析)**

```
shell> tcpdump 'gateway snup and (port ftp or ftp-data)'
```

- **抓取ping包**

```
[root@server2 ~]# tcpdump -c 5 -nn -i eth0 icmp 
```

如果明确要抓取主机为192.168.100.70对本机的ping，则使用and操作符。

```
[root@server2 ~]# tcpdump -c 5 -nn -i eth0 icmp and src 192.168.100.62
```

注意不能直接写icmp src 192.168.100.70，因为icmp协议不支持直接应用host这个type。

- **抓取到本机22端口包**

```
[root@server2 ~]# tcpdump -c 10 -nn -i eth0 tcp dst port 22  
```

- **解析包数据**

```
[root@server2 ~]# tcpdump -c 2 -q -XX -vvv -nn -i eth0 tcp dst port 22
tcpdump: listening on eth0, link-type EN10MB (Ethernet), capture size 65535 bytes
12:15:54.788812 IP (tos 0x0, ttl 64, id 19303, offset 0, flags [DF], proto TCP (6), length 40)
    192.168.100.1.5788 > 192.168.100.62.22: tcp 0
        0x0000:  000c 2908 9234 0050 56c0 0008 0800 4500  ..)..4.PV.....E.
        0x0010:  0028 4b67 4000 4006 a5d8 c0a8 6401 c0a8  .(Kg@.@.....d...
        0x0020:  643e 169c 0016 2426 5fd6 1fec 2b62 5010  d>....$&_...+bP.
        0x0030:  0803 7844 0000 0000 0000 0000            ..xD........
12:15:54.842641 IP (tos 0x0, ttl 64, id 19304, offset 0, flags [DF], proto TCP (6), length 40)
    192.168.100.1.5788 > 192.168.100.62.22: tcp 0
        0x0000:  000c 2908 9234 0050 56c0 0008 0800 4500  ..)..4.PV.....E.
        0x0010:  0028 4b68 4000 4006 a5d7 c0a8 6401 c0a8  .(Kh@.@.....d...
        0x0020:  643e 169c 0016 2426 5fd6 1fec 2d62 5010  d>....$&_...-bP.
        0x0030:  0801 7646 0000 0000 0000 0000            ..vF........
2 packets captured
2 packets received by filter
0 packets dropped by kernel
```

总的来说，tcpdump对基本的数据包抓取方法还是较简单的。只要掌握有限的几个选项(-nn -XX -vvv -i -c -q)，再组合表达式即可。

- **Raw Output View**

Use this combination to see verbose output, with no resolution of hostnames or port numbers, using absolute sequence numbers, and showing human-readable timestamps.

```
tcpdump -ttnnvvS
```

- **From specific IP and destined for a specific Port**

Let’s find all traffic from 10.5.2.3 going to any host on port 3389.

```
tcpdump -nnvvS src 10.5.2.3 and dst port 3389
```



- **From One Network to Another**

Let’s look for all traffic coming from 192.168.x.x and going to the 10.x or 172.16.x.x networks, and we’re showing hex output with no hostname resolution and one level of extra verbosity.

```
tcpdump -nvX src net 192.168.0.0/16 and dst net 10.0.0.0/8 or 172.16.0.0/16
```



- **Non ICMP Traffic Going to a Specific IP**

This will show us all traffic going to 192.168.0.2 that is *not* ICMP.

```
tcpdump dst 192.168.0.2 and src net and not icmp
```



- **Traffic From a Host That Isn’t on a Specific Port**

This will show us all traffic from a host that isn’t SSH traffic (assuming default port usage).

```
tcpdump -vv src mars and not dst port 22
```

As you can see, you can build queries to find just about anything you need. The key is to first figure out *precisely* what you’re looking for and then to build the syntax to isolate that specific type of traffic.

Keep in mind that when you’re building complex queries you might have to group your options using single quotes. Single quotes are used in order to tell `tcpdump` to ignore certain special characters—in this case below the “( )” brackets. This same technique can be used to group using other expressions such as `host`, `port`, `net`, etc.

```
tcpdump 'src 10.0.2.4 and (dst port 3389 or 22)'
```



- **<u>Isolate TCP Flags</u>**

You can also use filters to isolate packets with specific TCP flags set.

- **Isolate TCP RST flags.**

The filters below find these various packets because `tcp[13]`looks at offset 13 in the TCP header, the number represents the location within the byte, and the !=0 means that the flag in question is set to 1, i.e. it’s on.

```
tcpdump 'tcp[13] & 4!=0'
tcpdump 'tcp[tcpflags] == tcp-rst'
```

- **Isolate TCP SYN flags.**


```
tcpdump 'tcp[13] & 2!=0'
tcpdump 'tcp[tcpflags] == tcp-syn'
```

- **Isolate packets that have both the SYN and ACK flags set.**

```
tcpdump 'tcp[13]=18'
```

Only the PSH, RST, SYN, and FIN flags are displayed in `tcpdump`‘s flag field output. URGs and ACKs are displayed, but they are shown elsewhere in the output rather than in the flags field.

- **Isolate TCP URG flags.**

tcpdump 'tcp[13] & 32!=0'
tcpdump 'tcp[tcpflags] == tcp-urg'

- **Isolate TCP ACK flags.**

```
tcpdump 'tcp[13] & 16!=0'

tcpdump 'tcp[tcpflags] == tcp-ack'
```



- **Isolate TCP PSH flags.**

```
tcpdump 'tcp[13] & 8!=0'
tcpdump 'tcp[tcpflags] == tcp-psh'
```



- **Isolate TCP FIN flags.**

```
tcpdump 'tcp[13] & 1!=0'
tcpdump 'tcp[tcpflags] == tcp-fin'
```



- **Everyday Recipe Examples**

Because tcpdump can output content in ASCII, you can use it to search for cleartext content using other command-line tools like `grep`.

Finally, now that we the theory out of the way, here are a number of quick recipes you can use for catching various kinds of traffic.

- **Both SYN and RST Set**

tcpdump 'tcp[13] = 6'

- **Find HTTP User Agents**

The `-l` switch lets you see the traffic as you’re capturing it, and helps when sending to commands like `grep`.

tcpdump -vvAls0 | grep 'User-Agent:'

- **Cleartext GET Requests**

tcpdump -vvAls0 | grep 'GET'

- **Find HTTP Host Headers**

tcpdump -vvAls0 | grep 'Host:'

- **Find HTTP Cookies**

tcpdump -vvAls0 | grep 'Set-Cookie|Host:|Cookie:'

- **Find SSH Connections**

This one works regardless of what port the connection comes in on, because it’s getting the banner response.

tcpdump 'tcp[(tcp[12]>>2):4] = 0x5353482D'

- **Find DNS Traffic**

tcpdump -vvAs0 port 53

- **Find FTP Traffic**

tcpdump -vvAs0 port ftp or ftp-data

- **Find NTP Traffic**

tcpdump -vvAs0 port 123

- **Find Cleartext Passwords**

tcpdump port http or port ftp or port smtp or port imap or port pop3 or port telnet -lA | egrep -i -B5 'pass=|pwd=|log=|login=|user=|username=|pw=|passw=|passwd= |password=|pass:|user:|username:|password:|login:|pass |user '

- **Find traffic with evil bit**

There’s a bit in the IP header that never gets set by legitimate applications, which we call the “Evil Bit”. Here’s a fun filter to find packets where it’s been toggled.

tcpdump 'ip[6] & 128 != 0'





# 3.netstat

------



# 4.iptables

------

#查看
iptables -L -n -v
#清空所有规则
iptables -F

iptables -A INPUT -s  1.1.1.1  -j  ACCEPT
iptables -A INPUT -s 192.168.2.0/24 -j ACCEPT
iptables -A INPUT -s 0.0.0.0 -j DROP

# 5.ipset

------



# 6.yum

------



### 1. 常用命令

- 查看已安装:

yum list installed|grep HDP|awk '{print "yum remove -y "$1;}'|sort -u

- rpm下载包

rpm -e

- yum卸载

yum remove



### 2. 只下载不安装

How to use yum to download a package without installing it

 [原文在此](https://access.redhat.com/solutions/10154)

**Resolution**

There are two ways to download a package without installing it.

One is using the "downloadonly" plugin for yum, the other is using "yumdownloader" utility.

#### Downloadonly plugin for yum

1. Install the package including "downloadonly" plugin:

   ```
   (RHEL5)
   # yum install yum-downloadonly
   
   (RHEL6)
   # yum install yum-plugin-downloadonly
   ```

2. Run `yum` command with "--downloadonly" option as follows:

```
   # yum install --downloadonly --downloaddir=<directory> <package>
```

3. Confirm the RPM files are available in the specified download directory.

**Note:**

- Before using the plugin, check */etc/yum/pluginconf.d/downloadonly.conf* to confirm that this plugin is "enabled=1"
- This is applicable for "yum install/yum update" and not for "yum groupinstall". Use "yum groupinfo" to identify packages within a specific group.
- If only the package name is specified, the latest available package is downloaded (such as *sshd*). Otherwise, you can specify the full package name and version (such as *httpd-2.2.3-22.el5*).
- If you do not use the --downloaddir option, files are saved by default in */var/cache/yum/* in *rhel-{arch}-channel/packages*
- If desired, you can download multiple packages on the same command.
- You still need to re-download the repodata if the repodata expires before you re-use the cache. By default it takes two hours to expire.

#### Yumdownloader

If downloading a installed package, "yumdownloader" is useful.

1. Install the yum-utils package:

   ```
   # yum install yum-utils
   ```

2. Run the command followed by the desired package:

   ```
   # yumdownloader <package>
   ```

**Note:**

- The package is saved in the current working directly by default; use the --destdir option to specify an alternate location.
- Be sure to add --resolve if you need to download dependencies.



This solution is part of Red Hat’s fast-track publication program, providing a huge library of solutions that Red Hat engineers have created while supporting our customers. To give you the knowledge you need the instant it becomes available, these articles may be presented in a raw and unedited form.



### 3. Yum安装源码

以uname为例:

whereis uname

或者which sort

 rpm -qf /usr/bin/sort

coreutils-8.22-21.el7.x86_64



 yumdownloader --source coreutils

rpm -qpl ./coreutils-8.22-23.el7.src.rpm |grep tar
coreutils-8.22.tar.xz

 rpm2cpio coreutils-8.22-23.el7.src.rpm |cpio -idv  coreutils-8.22.tar.xz

tar xJvf  coreutils-8.22.tar.xz

### 4.查找命令在哪个包

以Centos 6 安装nslookup命令为例



#### Centos 6 安装nslookup命令

2015.12.23 14:16:32字数 344阅读 5630

##### 安装步骤

1. 執行 nslookup，系統回應「沒有這個指令」: 

   ```ruby
   $ nslookup
   -bash: nslookup: command not found
   ```

 

直覺地用 yum 安裝 nslookup，結果跟你說「套件不存在」: 

```csharp
$ yum install nslookup
Loaded plugins: fastestmirror
Loading mirror speeds from cached hostfile
 * base: mirrors.kernel.org
 * elrepo: ftp.osuosl.org
 * epel: mirrors.kernel.org
 * extras: mirrors.kernel.org
 * rpmforge: mirror.hmc.edu
 * updates: mirrors.kernel.org
Setting up Install Process
No package nslookup available.
Error: Nothing to do
```

 

我們可以加 *provides*

```csharp
$ yum provides nslookup
Loaded plugins: fastestmirror
Loading mirror speeds from cached hostfile
* base: mirrors.linode.com
* epel: mirror.prgmr.com
* extras: mirrors.linode.com
* rpmforge: mirror.hmc.edu
* updates: mirrors.linode.com
Warning: 3.0.x versions of yum would erroneously match against filenames.
You can use "*/nslookup" and/or "*bin/nslookup" to get that behaviour
No Matches found
```

 

雖然第一時間也是查不到，不過在上面遺留的訊息中， yum 有進一步顯示說檔案可能藏在 bin 目錄中。我們依樣畫葫蘆: 

```csharp
$ yum provides *bin/nslookup
Loaded plugins: fastestmirror
Loading mirror speeds from cached hostfile
* base: mirrors.linode.com
* epel: mirror.prgmr.com
* extras: mirrors.linode.com
* rpmforge: mirror.hmc.edu
* updates: mirrors.linode.com
32:bind-utils-9.8.2-0.17.rc1.el6_4.6.x86_64 : Utilities for querying DNS name
                                            : servers
Repo        : base
Matched from:
Filename    : /usr/bin/nslookup
```

 

事不宜遲，咱們快點安裝吧: 

```bash
$ yum install bind-utils
```

 PS. 連帶的 *dig**host*

# devtoolset

------

yum install centos-release-scl-rh centos-release-scl

yum -y install devtoolset-6-gcc-c++

source /opt/rh/devtoolset-6/enable



# systemd中文手册

------

## 版权声明

本文译者是一位开源理念的坚定支持者，所以本文虽然不是软件，但是遵照开源的精神发布。

- 无担保：本文译者不保证译文内容准确无误，亦不承担任何由于使用此文档所导致的损失。
- 自由使用：任何人都可以自由的阅读/链接/打印此文档，无需任何附加条件。
- 名誉权：任何人都可以自由的转载/引用/再创作此文档，但必须保留译者署名并注明出处。

## 其他作品

本文译者十分愿意与他人分享劳动成果，如果你对我的其他翻译作品或者技术文章有兴趣，可以在如下位置查看现有的作品集：

- [金步国作品集](http://www.jinbuguo.com/) [ http://www.jinbuguo.com/ ]

## 联系方式

由于译者水平有限，因此不能保证译文内容准确无误。如果你发现了译文中的错误(哪怕是错别字也好)，请来信指出，任何提高译文质量的建议我都将虚心接纳。

- Email(QQ)：70171448在QQ邮箱

------

## 名称

systemd.service — 服务单元配置

## 大纲

```
*service*.service
```



## 描述

以     `.service` 为后缀的单元文件，     封装了一个被 systemd 监视与控制的进程。

​     本手册列出了所有专用于此类单元的配置选项(亦称"配置指令"或"单元属性")。     [systemd.unit(5)](http://www.jinbuguo.com/systemd/systemd.unit.html#)     中描述了通用于所有单元类型的配置选项，     它们位于      "`[Unit]`" 与 "`[Install]`" 小节。     此类单元专用的配置选项位于 "`[Service]`" 小节。     

其他可用的选项参见     [systemd.exec(5)](http://www.jinbuguo.com/systemd/systemd.exec.html#)     手册(定义了命令的执行环境)，     以及     [systemd.kill(5)](http://www.jinbuguo.com/systemd/systemd.kill.html#)     手册(定义了如何结束进程)，     以及     [systemd.resource-control(5)](http://www.jinbuguo.com/systemd/systemd.resource-control.html#)     手册(定义了进程的资源控制)。     

​     如果要求启动或停止的某个单元文件不存在，     systemd 将会寻找同名的SysV初始化脚本(去掉 `.service` 后缀)，     并根据那个同名脚本动态的创建一个 service 单元。     这主要用于与传统的SysV兼容(不能保证100%兼容)。     更多与SysV的兼容性可参见 [Incompatibilities     with SysV](https://www.freedesktop.org/wiki/Software/systemd/Incompatibilities) 文档。     



## 隐含依赖

下列依赖关系是自动隐含的：

- 设置了 `Type=dbus` 的服务会自动添加        `Requires=dbus.socket` 与        `After=dbus.socket` 依赖。       
- 基于套接字启动的服务会自动添加对关联的       `.socket` 单元的 `After=` 依赖。       服务单元还会为所有在 `Sockets=` 中列出的        `.socket` 单元自动添加       `Wants=` 与 `After=` 依赖。       

​     [systemd.exec(5)](http://www.jinbuguo.com/systemd/systemd.exec.html#)     与     [systemd.resource-control(5)](http://www.jinbuguo.com/systemd/systemd.resource-control.html#)     中的某些资源限制选项也会自动隐含的添加一些其他的依赖关系。



## 默认依赖

除非明确设置了 `DefaultDependencies=no` ，否则 service 单元将会自动添加下列依赖关系：

-  `Requires=sysinit.target`, `After=sysinit.target`,       `After=basic.target`, `Conflicts=shutdown.target`, `Before=shutdown.target` 。       这样可以确保普通的服务单元：       (1)在基础系统启动完毕之后才开始启动，(2)在关闭系统之前先被干净的停止。       只有那些需要在系统启动的早期就必须启动的服务，       以及那些必须在关机动作的结尾才能停止的服务才需要设置 `DefaultDependencies=no` 。
- 从同一个模版实例化出来的所有服务单元(单元名称中带有 "`@`" 字符)，       默认全部属于与模版同名的同一个 slice 单元(参见       [systemd.slice(5)](http://www.jinbuguo.com/systemd/systemd.slice.html#))。       该同名 slice 一般在系统关机时，与所有模版实例一起停止。       如果你不希望像上面这样，那么可以在模版单元中明确设置 `DefaultDependencies=no` ，       并且：要么在该模版文件中明确定义特定的 slice 单元(同样也要明确设置 `DefaultDependencies=no`)、       要么在该模版文件中明确设置 `Slice=system.slice` (或其他合适的 slice)。       参见       [systemd.resource-control(5)](http://www.jinbuguo.com/systemd/systemd.resource-control.html#)       手册。



## 选项

​     每个服务单元文件都必须包含一个 [Service] 小节。     由于此小节中的许多选项也同时适用于其他类型的单元，     所以本手册仅记录了专用于服务单元的选项。     其他共享的选项参见     [systemd.exec(5)](http://www.jinbuguo.com/systemd/systemd.exec.html#),     [systemd.kill(5)](http://www.jinbuguo.com/systemd/systemd.kill.html#),     [systemd.resource-control(5)](http://www.jinbuguo.com/systemd/systemd.resource-control.html#)     手册。     这里只列出仅能用于 [Service] 小节的选项(亦称"指令"或"属性")：     

- `Type=`

  设置进程的启动类型，         必须设为         `simple`,         `forking`,         `oneshot`,         `dbus`,         `notify`,         `idle` 之一。如果设为 `simple`         (设置了 `ExecStart=`         但未设置 `BusName=` 时的默认值)，         那么表示         `ExecStart=`         进程就是该服务的主进程。         如果此进程需要为其他进程提供服务，         那么必须在该进程启动之前先建立好通信渠道(例如套接字)，         以加快后继单元的启动速度。         如果设为 `forking` ，         那么表示 `ExecStart=`         进程将会在启动过程中使用 `fork()` 系统调用。         这是传统UNIX守护进程的经典做法。         也就是当所有的通信渠道都已建好、启动亦已成功之后，         父进程将会退出，而子进程将作为该服务的主进程继续运行。         对于此种进程，         建议同时设置 `PIDFile=` 选项，         以帮助 systemd 准确定位该服务的主进程，         进而加快后继单元的启动速度。         `oneshot`         (未设置 `ExecStart=` 时的默认值)         与 `simple` 类似，         不同之处在于该进程必须在 systemd 启动后继单元之前退出。         此种类型通常需要设置         `RemainAfterExit=` 选项。         `dbus`         (既设置了 `ExecStart=` 也设置了 `BusName=` 时的默认值)         与 `simple` 类似，         不同之处在于该进程需要在 D-Bus 上获得一个由         `BusName=` 指定的名称。         systemd 将会在启动后继单元之前，         首先确保该进程已经成功的获取了指定的 D-Bus 名称。         设为此类型相当于隐含的依赖于 `dbus.socket` 单元。         `notify` 与         `simple` 类似，         不同之处在于该进程将会在启动完成之后通过         [sd_notify(3)](http://www.jinbuguo.com/systemd/sd_notify.html#)         之类的接口发送一个通知消息。         systemd 将会在启动后继单元之前，         首先确保该进程已经成功的发送了这个消息。         如果设为此类型，         那么下文的 `NotifyAccess=` 将只能设为非 `none` 值。         如果 `NotifyAccess=` 未设置，         或者已经被明确设为 `none` ，         那么将会被自动强制修改为 `main` 。         注意，目前 `Type=``notify`         尚不能在 `PrivateNetwork=``yes`         的情况下正常工作。`idle` 与 `simple` 类似，         不同之处在于该进程将会被延迟到所有活动的任务都完成之后再执行。         这样可以避免控制台上的状态信息与shell脚本的输出混杂在一起。         注意：(1) `idle` 仅可用于改善控制台输出，切勿将其用于不同单元之间的排序工具；         (2)延迟最多不超过5秒，超时后将无条件的启动服务进程。

- `RemainAfterExit=`

  当该服务的所有进程全部退出之后，         是否依然将此服务视为活动(active)状态。         默认值为 `no`

- `GuessMainPID=`

  ​         在无法明确定位该服务主进程的情况下，         systemd 是否应该猜测主进程的PID(可能不正确)。         该选项仅在设置了         `Type=forking`         但未设置         `PIDFile=`         的情况下有意义。         如果PID猜测错误，         那么该服务的失败检测与自动重启功能将失效。         默认值为 `yes`

- `PIDFile=`

  ​         守护进程的PID文件，必须是绝对路径。         强烈建议在         `Type=``forking`         的情况下明确设置此选项。         systemd 将会在此服务启动后从此文件中读取主守护进程的PID 。         systemd 不会写入此文件，         但会在此服务停止后删除它(若存在)。         

- `BusName=`

  ​         设置与此服务通信所使用的 D-Bus 名称。         在 `Type=``dbus` 的情况下         必须明确设置此选项。

- `ExecStart=`

  ​         在启动该服务时需要执行的命令行(命令+参数)。         有关命令行的更多细节，         可参见后文的"命令行"小节。         除非 `Type=oneshot` ，否则必须且只能设置一个命令行。         仅在 `Type=oneshot` 的情况下，才可以设置任意个命令行(包括零个)，         多个命令行既可以在同一个 `ExecStart=` 中设置，也可以通过设置多个 `ExecStart=` 来达到相同的效果。         如果设为一个空字符串，那么先前设置的所有命令行都将被清空。         如果不设置任何 `ExecStart=` 指令，         那么必须确保设置了 `RemainAfterExit=yes` 指令，并且至少设置一个 `ExecStop=` 指令。         同时缺少 `ExecStart=` 与         `ExecStop=` 的服务单元是非法的(也就是必须至少明确设置其中之一)。命令行必须以一个绝对路径表示的可执行文件开始，并且其后的那些参数将依次作为"argv[1] argv[2] …"传递给被执行的进程。         可选的，可以在绝对路径前面加上各种不同的前缀表示不同的含义：**表 1. 可执行文件前的特殊前缀**前缀效果"`@`"如果在绝对路径前加上可选的 "`@`" 前缀，那么其后的那些参数将依次作为"argv[0] argv[1] argv[2] …"传递给被执行的进程(注意，argv[0] 是可执行文件本身)。"`-`"如果在绝对路径前加上可选的 "`-`" 前缀，那么即使该进程以失败状态(例如非零的返回值或者出现异常)退出，也会被视为成功退出。"`+`"如果在绝对路径前加上可选的 "`+`" 前缀，那么进程将拥有完全的权限(超级用户的特权)，并且 `User=`, `Group=`, `CapabilityBoundingSet=` 选项所设置的权限限制以及 `PrivateDevices=`, `PrivateTmp=` 等文件系统名字空间的配置将被该命令行启动的进程忽略(但仍然对其他 `ExecStart=`, `ExecStop=` 有效)。"`!`"与 "`+`" 类似(进程仍然拥有超级用户的身份)，不同之处在于仅忽略 `User=`, `Group=`, `SupplementaryGroups=` 选项的设置，而例如名字空间之类的其他限制依然有效。注意，当与 `DynamicUser=` 一起使用时，将会在执行该命令之前先动态分配一对 user/group ，然后将身份凭证的切换操作留给进程自己去执行。"`!!`"与 "`!`" 极其相似，仅用于让利用 ambient capability 限制进程权限的单元兼容不支持 ambient capability 的系统(也就是不支持 `AmbientCapabilities=` 选项)。如果在不支持 ambient capability 的系统上使用此前缀，那么 `SystemCallFilter=` 与 `CapabilityBoundingSet=` 将被隐含的自动修改为允许进程自己丢弃 capability 与特权用户的身份(即使原来被配置为禁止这么做)，并且 `AmbientCapabilities=` 选项将会被忽略。此前缀在支持 ambient capability 的系统上完全没有任何效果。 "`@`", "`-`" 以及         "`+`"/"`!`"/"`!!`" 之一，可以按任意顺序同时混合使用。         注意，对于 "`+`", "`!`", "`!!`" 前缀来说，仅能单独使用三者之一，不可混合使用多个。         注意，这些前缀同样也可以用于          `ExecStartPre=`, `ExecStartPost=`, `ExecReload`,         `ExecStop=`, `ExecStopPost=` 这些接受命令行的选项。如果设置了多个命令行，         那么这些命令行将以其在单元文件中出现的顺序依次执行。         如果某个无 "`-`" 前缀的命令行执行失败，         那么剩余的命令行将不会被继续执行，         同时该单元将变为失败(failed)状态。当未设置 `Type=forking` 时，         这里设置的命令行所启动的进程         将被视为该服务的主守护进程。

- `ExecStartPre=`, `ExecStartPost=`

  ​         设置在执行 `ExecStart=` 之前/后执行的命令行。         语法规则与 `ExecStart=` 完全相同。         如果设置了多个命令行，         那么这些命令行将以其在单元文件中出现的顺序依次执行。         如果某个无 "`-`" 前缀的命令行执行失败，         那么剩余的命令行将不会被继续执行，         同时该单元将变为失败(failed)状态。仅在所有无 "`-`" 前缀的         `ExecStartPre=` 命令全部执行成功的前提下，         才会继续执行 `ExecStart=` 命令。`ExecStartPost=` 命令仅在 `ExecStart=` 中的命令已经全部执行成功之后才会运行，         判断的标准基于 `Type=` 选项。         具体说来，对于 `Type=simple` 或 `Type=idle` 就是主进程已经成功启动；         对于 `Type=oneshot` 来说就是最后一个 `ExecStart=` 进程已经成功退出；         对于 `Type=forking` 来说就是初始进程已经成功退出；         对于 `Type=notify` 来说就是已经发送了 "`READY=1`" ；         对于 `Type=dbus` 来说就是已经取得了 `BusName=` 中设置的总线名称。         注意，不可将 `ExecStartPre=` 用于需要长时间执行的进程。         因为所有由 `ExecStartPre=` 派生的子进程         都会在启动 `ExecStart=` 服务进程之前被杀死。注意，如果在服务启动完成之前，任意一个 `ExecStartPre=`,         `ExecStart=`, `ExecStartPost=`         中无 "`-`" 前缀的命令执行失败或超时，         那么，`ExecStopPost=` 将会被继续执行，而 `ExecStop=` 则会被跳过。

- `ExecReload=`

  ​         这是一个可选的指令，         用于设置当该服务被要求重新载入配置时所执行的命令行。         语法规则与         `ExecStart=`         完全相同。         另外，还有一个特殊的环境变量         `$MAINPID`         可用于表示主进程的PID，         例如可以这样使用：`/bin/kill -HUP $MAINPID`注意，像上例那样，通过向守护进程发送复位信号，         强制其重新加载配置文件，并不是一个好习惯。         因为这是一个异步操作，         所以不适用于需要按照特定顺序重新加载配置文件的服务。         我们强烈建议将         `ExecReload=`         设为一个         能够确保重新加载配置文件的操作同步完成的命令行。

- `ExecStop=`

  这是一个可选的指令，         用于设置当该服务被要求停止时所执行的命令行。         语法规则与         `ExecStart=`         完全相同。         执行完此处设置的所有命令行之后，该服务将被视为已经停止，         此时，该服务所有剩余的进程将会根据 `KillMode=` 的设置被杀死(参见         [systemd.kill(5)](http://www.jinbuguo.com/systemd/systemd.kill.html#))。         如果未设置此选项，那么当此服务被停止时，         该服务的所有进程都将会根据 `KillSignal=`         的设置被立即全部杀死。         与 `ExecReload=` 一样，         也有一个特殊的环境变量 `$MAINPID` 可用于表示主进程的PID 。         一般来说，不应该仅仅设置一个结束服务的命令而不等待其完成。         因为当此处设置的命令执行完之后，         剩余的进程会被按照 `KillMode=` 与 `KillSignal=` 的设置立即杀死，         这可能会导致数据丢失。         因此，这里设置的命令必须是同步操作，而不能是异步操作。注意，仅在服务确实启动成功的前提下，才会执行 `ExecStop=` 中设置的命令。         如果服务从未启动或启动失败(例如，任意一个         `ExecStart=`, `ExecStartPre=`, `ExecStartPost=`         中无 "`-`" 前缀的命令执行失败或超时)，         那么 `ExecStop=` 将会被跳过。         如果想要无条件的在服务停止后执行特定的动作，那么应该使用 `ExecStopPost=` 选项。应该将此选项用于那些必须在服务干净的退出之前执行的命令。         当此选项设置的命令被执行的时候，应该假定服务正处于完全正常的运行状态，可以正常的与其通信。         如果想要无条件的在服务停止后"清理尸体"，那么应该使用 `ExecStopPost=` 选项。        

- `ExecStopPost=`

  这是一个可选的指令，         用于设置在该服务停止之后所执行的命令行。         语法规则与         `ExecStart=`         完全相同。         注意，与 `ExecStop=` 不同，无论服务是否启动成功，         此选项中设置的命令都会在服务停止后被无条件的执行。         应该将此选项用于设置那些无论服务是否启动成功都必须在服务停止后无条件执行的清理操作。         此选项设置的命令必须能够正确处理由于服务启动失败而造成的各种残缺不全以及数据不一致的场景。         由于此选项设置的命令在执行时，整个服务的所有进程都已经全部结束，所以无法与服务进行任何通信。         注意，此处设置的所有命令在被调用之后都可以读取如下环境变量：          `$SERVICE_RESULT`(服务的最终结果),         `$EXIT_CODE`(服务主进程的退出码), `$EXIT_STATUS`(服务主进程的退出状态)。         详见 [systemd.exec(5)](http://www.jinbuguo.com/systemd/systemd.exec.html#) 手册。         

- `RestartSec=`

  设置在重启服务(`Restart=`)前暂停多长时间。         默认值是100毫秒(100ms)。         如果未指定时间单位，那么将视为以秒为单位。         例如设为"20"等价于设为"20s"。

- `TimeoutStartSec=`

  设置该服务允许的最大启动时长。         如果守护进程未能在限定的时长内发出"启动完毕"的信号，那么该服务将被视为启动失败，并会被关闭。         如果未指定时间单位，那么将视为以秒为单位。         例如设为"20"等价于设为"20s"。         设为 "`infinity`" 则表示永不超时。         当 `Type=oneshot` 时，         默认值为 "`infinity`" (永不超时)，         否则默认值等于         `DefaultTimeoutStartSec=`         的值(参见         [systemd-system.conf(5)](http://www.jinbuguo.com/systemd/systemd-system.conf.html#) 手册)。         

- `TimeoutStopSec=`

  设置该服务允许的最大停止时长。         如果该服务未能在限定的时长内成功停止，         那么将会被强制使用 `SIGTERM` 信号关闭，         如果依然未能在相同的时长内成功停止，         那么将会被强制使用 `SIGKILL` 信号关闭(参见         [systemd.kill(5)](http://www.jinbuguo.com/systemd/systemd.kill.html#)         手册中的 `KillMode=` 选项)。         如果未指定时间单位，那么将视为以秒为单位。         例如设为"20"等价于设为"20s"。         设为 "`infinity`" 则表示永不超时。         默认值等于         `DefaultTimeoutStopSec=` 的值(参见         [systemd-system.conf(5)](http://www.jinbuguo.com/systemd/systemd-system.conf.html#) 手册)。         

- `TimeoutSec=`

  一个同时设置         `TimeoutStartSec=` 与         `TimeoutStopSec=` 的快捷方式。         

- `RuntimeMaxSec=`

  允许服务持续运行的最大时长。         如果服务持续运行超过了此处限制的时长，那么该服务将会被强制终止，同时将该服务变为失败(failed)状态。         注意，此选项对 `Type=oneshot` 类型的服务无效，因为它们会在启动完成后立即终止。         默认值为 "`infinity`" (不限时长)。         

- `WatchdogSec=`

  设置该服务的看门狗(watchdog)的超时时长。         看门狗将在服务成功启动之后被启动。         该服务在运行过程中必须周期性的以 "`WATCHDOG=1`" ("keep-alive ping")调用         [sd_notify(3)](http://www.jinbuguo.com/systemd/sd_notify.html#)         函数。         如果在两次调用之间的时间间隔大于这里设定的值，         那么该服务将被视为失败(failed)状态，         并会被强制使用 `SIGABRT` 信号关闭。         通过将         `Restart=` 设为 `on-failure`,         `on-watchdog`, `on-abnormal`,         `always` 之一，         可以实现在失败状态下的自动重启该服务。         这里设置的值将会通过         `WATCHDOG_USEC=` 环境变量传递给守护进程，         这样就允许那些支持看门狗的服务自动启用"keep-alive ping"。         如果设置了此选项，         那么 `NotifyAccess=` 将只能设为非 `none` 值。         如果 `NotifyAccess=` 未设置，或者已经被明确设为 `none` ，         那么将会被自动强制修改为 `main` 。         如果未指定时间单位，那么将视为以秒为单位。         例如设为"20"等价于设为"20s"。         默认值"0"表示禁用看门狗功能。         详见         [sd_watchdog_enabled(3)](http://www.jinbuguo.com/systemd/sd_watchdog_enabled.html#)         与         [sd_event_set_watchdog(3)](http://www.jinbuguo.com/systemd/sd_event_set_watchdog.html#)         手册。         

- `Restart=`

  ​         当服务进程正常退出、异常退出、被杀死、超时的时候，         是否重新启动该服务。         所谓"服务进程"是指         `ExecStartPre=`,         `ExecStartPost=`,         `ExecStop=`,         `ExecStopPost=`,         `ExecReload=` 中设置的进程。         当进程是由于 systemd 的正常操作(例如 **systemctl stop|restart**)而被停止时，         该服务不会被重新启动。         所谓"超时"可以是看门狗的"keep-alive ping"超时，         也可以是 **systemctl start|reload|stop** 操作超时。该选项的值可以取         `no`,         `always`,         `on-success`,         `on-failure`,         `on-abnormal`,         `on-watchdog`,         `on-abort` 之一。         `no`(默认值)         表示不会被重启。         `always`         表示会被无条件的重启。         `on-success`         表示仅在服务进程正常退出时重启，         所谓"正常退出"是指：         退出码为"0"，         或者进程收到         `SIGHUP`,         `SIGINT`,         `SIGTERM`,         `SIGPIPE`         信号之一，         并且退出码符合         `SuccessExitStatus=` 的设置。         `on-failure`         表示仅在服务进程异常退出时重启，         所谓"异常退出"是指：         退出码不为"0"，         或者进程被强制杀死(包括         "core dump"以及收到         `SIGHUP`,         `SIGINT`,         `SIGTERM`,         `SIGPIPE`         之外的其他信号)，         或者进程由于看门狗或者 systemd 的操作超时而被杀死。         **表 2. Restart= 的设置分别对应于哪些退出原因**退出原因(↓) | Restart= (→)`no``always``on-success``on-failure``on-abnormal``on-abort``on-watchdog`正常退出 XX    退出码不为"0" X X   进程被强制杀死 X XXX systemd 操作超时 X XX  看门狗超时 X XX X 注意如下例外情况(详见下文)：         (1) `RestartPreventExitStatus=`             中列出的退出码或信号永远不会导致该服务被重启。         (2) 被 **systemctl stop** 命令或等价的操作停止的服务永远不会被重启。         (3) `RestartForceExitStatus=`             中列出的退出码或信号将会无条件的导致该服务被重启。         注意，服务的重启频率仍然会受到由          `StartLimitIntervalSec=`         与 `StartLimitBurst=` 定义的启动频率的制约。详见         [systemd.unit(5)](http://www.jinbuguo.com/systemd/systemd.unit.html#)         手册。         对于需要长期持续运行的守护进程，         推荐设为 `on-failure` 以增强可用性。         对于自身可以自主选择何时退出的服务，         推荐设为 `on-abnormal`         

- `SuccessExitStatus=`

  ​         额外定义附加的进程"正常退出"状态。         可以设为一系列以空格分隔的数字退出码或者信号名称，         例如：          `SuccessExitStatus=1 2 8 SIGKILL`          表示当进程的退出码是 1, 2, 8         或被 `SIGKILL` 信号终止时，         都可以视为"正常退出"。         注意，退出码"0"以及 `SIGHUP`,         `SIGINT`, `SIGTERM`,         `SIGPIPE` 信号是标准的"正常退出"，         不需要在此特别定义。         如果多次使用此选项，         那么最终的结果将是多个列表的合并。         如果将此选项设为空，         那么先前设置的列表将被清空。         

- `RestartPreventExitStatus=`

  ​         可以设为一系列以空格分隔的数字退出码或信号名称，         当进程的退出码或收到的信号与此处的设置匹配时，         无论 `Restart=` 是如何设置的，         该服务都将无条件的禁止重新启动。         例如：          `RestartPreventExitStatus=1 6 SIGABRT`          可以确保退出码  1, 6  与 `SIGABRT` 信号         不会导致该服务被自动重启。         默认值为空，         表示完全遵守 `Restart=` 的设置。         如果多次使用此选项，         那么最终的结果将是多个列表的合并。         如果将此选项设为空，         那么先前设置的列表将被清空。         

- `RestartForceExitStatus=`

  可以设为一系列以空格分隔的数字退出码或信号名称，         当进程的退出码或收到的信号与此处的设置匹配时，         无论 `Restart=` 是如何设置的，该服务都将无条件的被自动重新启动。         默认值为空，表示完全遵守 `Restart=` 的设置。         如果多次使用此选项，那么最终的结果将是多个列表的合并。         如果将此选项设为空，那么先前设置的列表将被清空。

- `PermissionsStartOnly=`

  ​         设为 yes 表示所有与权限相关的执行选项(例如         `User=` 之类的选项，参见         [systemd.exec(5)](http://www.jinbuguo.com/systemd/systemd.exec.html#)         手册)仅对         `ExecStart=`         中的程序有效，而对         `ExecStartPre=`,         `ExecStartPost=`,         `ExecReload=`,         `ExecStop=`,         `ExecStopPost=` 中的程序无效。         默认值 no 表示所有与权限相关的执行选项，         对所有 `Exec*=` 系列选项中的程序都有效。

- `RootDirectoryStartOnly=`

  设为 yes 表示根目录(参见         [systemd.exec(5)](http://www.jinbuguo.com/systemd/systemd.exec.html#)         中的         `RootDirectory=`         选项)仅对         `ExecStart=` 中的程序有效，         而对 `ExecStartPre=`,         `ExecStartPost=`,         `ExecReload=`, `ExecStop=`,         and `ExecStopPost=` 中的程序无效。         默认值 no 表示         根目录对所有 `Exec*=` 系列选项中的程序都有效。

- `NonBlocking=`

  是否为所有基于套接字启动传递的文件描述符设置非阻塞标记(`O_NONBLOCK`)。         设为 yes 表示除了通过 `FileDescriptorStoreMax=` 引入的文件描述符之外，         所有 ≥3 的文件描述符(非 stdin, stdout, stderr 文件描述符)都将被设为非阻塞模式。         该选项仅在与 socket 单元         ([systemd.socket(5)](http://www.jinbuguo.com/systemd/systemd.socket.html#))         联用的时候才有意义。         对于那些先前已经通过 `FileDescriptorStoreMax=` 引入的文件描述符则毫无影响。         默认值为 no 

- `NotifyAccess=`

  设置通过         [sd_notify(3)](http://www.jinbuguo.com/systemd/sd_notify.html#)         访问服务状态通知套接字的模式。         可以设为 `none`(默认值), `main`, `exec`, `all` 之一。         `none` 表示不更新任何守护进程的状态，忽略所有状态更新消息。         `main` 表示仅接受主进程的状态更新消息。         `exec` 表示仅接受主进程以及 `Exec*=` 进程的状态更新消息。         `all` 表示接受该服务cgroup内所有进程的状态更新消息。         当设置了 `Type=notify` 或 `WatchdogSec=` 的时候(见前文)，此选项将只能设为非 `none` 值。         如果 `NotifyAccess=` 未设置，或者已经被明确设为 `none` ，         那么将会被自动强制修改为 `main` 。注意，服务单元的 `sd_notify()` 通知能够正常工作的前提，         是必须满足如下两个条件之一：         (1)在 PID=1 的进程处理通知消息时，发送该通知的进程依然在运行；         (2)发送该通知的进程是 systemd 派生的子进程(也就是匹配 `main` 或 `exec` 的进程)。         如果服务单元中的某个辅助进程在发送了 `sd_notify()` 通知之后就立即退出了，         那么 systemd 将有可能来不及将该通知关联到这个服务单元上。         在这种情况下，即使明确设置了 `NotifyAccess=all` ，         该通知也可能会被忽略掉。

- `Sockets=`

  ​         设置一个 socket 单元的名称，         表示该服务在启动时应当从它继承套接字文件描述符。         通常并不需要明确设置此选项，         因为所有与该服务同名(不算后缀)的 socket 单元的套接字文件描述符，         都会被自动的传递给派生进程。         注意：         (1)同一个套接字文件描述符可以被传递给多个不同的进程(服务)。         (2)当套接字上有流量进入时，         被启动的可能是另一个不同于该服务的其他服务。         换句话说就是：         套接字单元中的 `Sockets=`         所指向的服务单元中的 `Sockets=`         未必要反向指回去。         如果多次使用此选项，         那么最终的结果将是多个socket单元的合集。         如果将此选项设为空，         那么先前设置的所有socket单元都将被清空。         

- `FailureAction=`

  当该服务进入失败(failed)状态时所触发的动作。         取值范围及值的含义都与 `StartLimitAction=` (参见         [systemd.unit(5)](http://www.jinbuguo.com/systemd/systemd.unit.html#)) 完全相同。         默认值为 `none` 

- `FileDescriptorStoreMax=`

  允许在 systemd 中最多为该服务存储多少个使用         "`FDSTORE=1`" 消息([sd_pid_notify_with_fds(3)](http://www.jinbuguo.com/systemd/sd_pid_notify_with_fds.html#))         的文件描述符。默认值为"0"(不存储)。         通过将服务重启过程中不应该关闭的套接字与文件描述符使用这种方法保存起来，         就可以实现让服务在重启(正常重启或崩溃重启)之后不丢失其状态。         进程的状态可以被序列化为一个文件之后保存在 `/run` 中，         或者保存在一个 [memfd_create(2)](http://man7.org/linux/man-pages/man2/memfd_create.2.html) 内存文件描述符中(这是更好的选择)。         所有被 systemd 暂存的文件描述符都将在该服务重启之后交还给该服务的主进程。         所有被 systemd 暂存的文件描述符都将在遇到如下两种情况时被自动关闭：         (1)收到 `POLLHUP` 或 `POLLERR` 信号；         (2)该服务被彻底停止，并且没有任何剩余的任务需要处理。         

- `USBFunctionDescriptors=`

  设为一个包含         [USB         FunctionFS](https://www.kernel.org/doc/Documentation/usb/functionfs.txt) 描述符的文件路径，         以实现 USB gadget 支持。         仅与配置了 `ListenUSBFunction=`         的 socket 单元一起使用。该文件的内容将被写入         `ep0` 文件。         

- `USBFunctionStrings=`

  设为一个包含         [USB FunctionFS](https://www.kernel.org/doc/Documentation/usb/functionfs.txt) 字符串的文件路径。         其行为与上面的 `USBFunctionDescriptors=`         类似。

参见     [systemd.exec(5)](http://www.jinbuguo.com/systemd/systemd.exec.html#)     与     [systemd.kill(5)](http://www.jinbuguo.com/systemd/systemd.kill.html#)     手册，以了解更多其他选项。



## 命令行

本小节讲解     `ExecStart=`,     `ExecStartPre=`,     `ExecStartPost=`,     `ExecReload=`,     `ExecStop=`,     `ExecStopPost=`     选项的命令行解析规则。

如果要一次设置多个命令，那么可以使用分号(;)将多个命令行连接起来。     注意，仅在设置了 `Type=oneshot` 的前提下，才可以一次设置多个命令。     分号自身必须用 "`\;`" 表示。     

​     每个命令行的内部都以空格分隔，     第一项是要运行的命令，     随后的各项则是命令的参数。     每一项的边界都可以用单引号或双引号界定，     但引号自身最终将会被剥离。     还可以使用C语言风格的转义序列，     但仅可使用下文表格中的转义序列。     最后，行尾的反斜杠("`\`")将被视作续行符(借鉴了bash续行语法)。     

​     命令行的语法刻意借鉴了shell中的转义字符与变量展开语法，但两者并不完全相同。     特别的，     重定向("`<`",     "`<<`",     "`>`",     "`>>`")、     管道("`|`")、     后台运行("`&`")，     以及*其他下文未明确提及的符号*都不被支持。

要运行的命令(第一项)必须使用绝对路径表示。     可以在其中包含空格，但是不能包含控制字符。

​     可以在各项命令参数中使用 "`%`" 系列替换标记(详见     [systemd.unit(5)](http://www.jinbuguo.com/systemd/systemd.unit.html#)     手册)，     但不可用于命令自身(第一项)。

​     支持 "`${FOO}`" 与 "`$FOO`"     两种不同的环境变量替换方式。     具体说来就是：     "`${FOO}`" 的内容将原封不动的转化为一个单独的命令行参数，     无论其中是否包含空格与引号，也无论它是否为空。     "`$FOO`" 的内容将被原封不动的插入命令行中，     但对插入内容的解释却遵守一般的命令行解析规则。     下面的两个例子，将能清晰的体现两者的差别：     

例(1)：

```
Environment="ONE=one" 'TWO=two two'
ExecStart=/bin/echo $ONE $TWO ${TWO}
```

这将给 **/bin/echo** 命令依次传递如下四个参数:     "`one`", "`two`",     "`two`", "`two two`"

例(2)：

```
Environment=ONE='one' "TWO='two two' too" THREE=
ExecStart=/bin/echo ${ONE} ${TWO} ${THREE}
ExecStart=/bin/echo $ONE $TWO $THREE
```

这将导致 **/bin/echo** 被执行两次。     第一次被依次传递如下三个参数：     "`'one'`",     "`'two two' too`", "``" ；     第二次被依次传递如下三个参数：     "`one`", "`two two`",     "`too`" 。     

此外，如果想要传递美元符号($)自身，     则必须使用 "`$$`" 。     而那些无法在替换时确定内容的变量将被当做空字符串。     注意，不可以在第一项(也就是命令的绝对路径)中使用变量替换。

注意，这里使用的变量必须已经在     `Environment=` 或     `EnvironmentFile=` 中定义。     此外，在     [systemd.exec(5)](http://www.jinbuguo.com/systemd/systemd.exec.html#)     手册的"环境变量"小节中列出的"静态变量"也可以使用。     例如 `$USER` 就是一个"静态变量"，     而 `$TERM` 则不是。

​     注意，这里的命令行并不直接支持shell命令，     但是可以通过模仿下面这个变通的方法来实现：

```
ExecStart=/bin/sh -c 'dmesg | tac'
```

例一

```
ExecStart=/bin/echo one ; /bin/echo "two two"
```

这将导致 **/bin/echo** 被执行两次。     第一次被传递了单独一个 "`one`" 参数；     第二次被传递了单独一个 "`two two`" 参数。     因为一次设置了多个命令，所以仅能用于 `Type=oneshot` 类型。

例二

```
ExecStart=/bin/echo / >/dev/null & \; \
/bin/ls
```

这表示向 **/bin/echo**     命令传递五个参数： "`/`",     "`>/dev/null`",     "`&`", "`;`",     "`/bin/ls`"



**表 3. 可以在命令行与环境变量中使用的C语言风格的转义序列**

| 转义序列   | 实际含义                     |
| ---------- | ---------------------------- |
| "`\a`"     | 响铃                         |
| "`\b`"     | 退格                         |
| "`\f`"     | 换页                         |
| "`\n`"     | 换行                         |
| "`\r`"     | 回车                         |
| "`\t`"     | 制表符                       |
| "`\v`"     | 纵向制表符                   |
| "`\\`"     | 反斜线                       |
| "`\"`"     | 双引号                       |
| "`\'`"     | 单引号                       |
| "`\s`"     | 空白                         |
| "`\x*xx*`" | 十六进制数 *xx* 所对应的字符 |
| "`\*nnn*`" | 八进制数 *nnn* 所对应的字符  |





## 例子



**例 1. 简单服务**

下面的单元文件创建了一个运行        `/usr/sbin/foo-daemon` 守护进程的服务。       未设置 `Type=` 等价于       `Type=``simple` 默认设置。       systemd 执行守护进程之后，       即认为该单元已经启动成功。

```
[Unit]
Description=简单的Foo服务

[Service]
ExecStart=/usr/sbin/foo-daemon

[Install]
WantedBy=multi-user.target
```

注意，本例中的 `/usr/sbin/foo-daemon`       必须在启动后持续运行到服务被停止。       如果该进程只是为了派生守护进程，那么应该使用       `Type=``forking`

因为没有设置 `ExecStop=` 选项，       所以在停止服务时，systemd 将会直接向该服务启动的所有进程发送 SIGTERM 信号。       若超过指定时间依然存在未被杀死的进程，那么将会继续发送 SIGKILL 信号。       详见       [systemd.kill(5)](http://www.jinbuguo.com/systemd/systemd.kill.html#)       手册。

默认的 `Type=``simple`       并不包含任何通知机制(例如通知"服务启动成功")。       要想使用通知机制，应该将 `Type=` 设为其他非默认值：       `Type=``notify`       可用于能够理解 systemd 通知协议的服务；       `Type=``forking`       可用于能将自身切换到后台的服务；       `Type=``dbus`       可用于能够在完成初始化之后获得一个 D-Bus 名称的单元。       





**例 2. 一次性服务**

`Type=``oneshot`       用于那些只需要执行一次性动作而不需要持久运行的单元，       例如文件系统检查或者清理临时文件。       此类单元，       将会在启动后一直等待指定的动作完成，       然后再回到停止状态。       下面是一个执行清理动作的单元：

```
[Unit]
Description=清理老旧的 Foo 数据

[Service]
Type=oneshot
ExecStart=/usr/sbin/foo-cleanup

[Install]
WantedBy=multi-user.target
```

注意，在 `/usr/sbin/foo-cleanup` 执行结束前，       该服务一直处于"启动中"(activating)状态，而一旦执行结束，该服务又立即变为"停止"(inactive)状态。       也就是说，对于 `Type=``oneshot` 类型的服务，不存在"活动"(active)状态。       这意味着，如果再一次启动该服务，将会再一次执行该服务定义的动作。       注意，在先后顺序上晚于该服务的单元，       将会一直等到该服务变成"停止"(inactive)状态后，       才会开始启动。

`Type=``oneshot`       是唯一可以设置多个 `ExecStart=` 指令的服务类型。       多个 `ExecStart=` 指令将按照它们出现的顺序依次执行，       一旦遇到错误，就会立即停止，不再继续执行，       同时该服务也将进入"失败"(failed)状态。





**例 3. 可停止的一次性服务**

​       有时候，单元需要执行一个程序以完成某个设置(启动)，       然后又需要再执行另一个程序以撤消先前的设置(停止)，       而在设置持续有效的时段中，该单元应该视为处于"活动"(active)状态，       但实际上并无任何程序在持续运行。       网络配置服务就是一个典型的例子。       此外，只能启动一次(不可多次启动)的一次性服务，也是一个例子。       

可以通过设置       `RemainAfterExit=``yes` 来满足这种需求。       在这种情况下，systemd 将会在启动成功后将该单元视为处于"活动"(active)状态(而不是"停止"(inactive)状态)。       `RemainAfterExit=``yes` 虽然可以用于所有 `Type=` 类型，       但是在实践中主要用于       `Type=``oneshot` 和       `Type=``simple` 类型。       对于 `Type=``oneshot` 类型，       systemd 一直等到服务启动成功之后，才会将该服务置于"活动"(active)状态。       所以，依赖于该服务的其他单元必须等待该服务启动成功之后，才能启动。       但是对于       `Type=``simple` 类型，       依赖于该服务的其他单元无需等待，将会和该服务同时并行启动。       下面的类似展示了一个简单的静态防火墙服务：       

```
[Unit]
Description=简单的静态防火墙

[Service]
Type=oneshot
RemainAfterExit=yes
ExecStart=/usr/local/sbin/simple-firewall-start
ExecStop=/usr/local/sbin/simple-firewall-stop

[Install]
WantedBy=multi-user.target
```

因为服务启动成功后一直处于"活动"(active)状态，       所以再次执行 **systemctl start**       命令不会有任何效果。





**例 4. 传统的服务**

多数传统的守护进程(服务)在启动时会转入后台运行。       systemd 通过       `Type=``forking` 来支持这种工作方式。       对于这种类型的服务，如果最初启动的进程尚未退出，       那么该单元将依然处于"启动中"(activating)状态。       当最初的进程成功退出，       并且至少有一个进程仍然在运行(并且       `RemainAfterExit=``no`)，       该服务才会被视为处于"活动"(active)状态。

对于单进程的传统服务，当最初的进程成功退出后，       将会只剩单独一个进程仍然在持续运行，       systemd 将会把这个唯一剩余的进程视为该服务的主进程。       仅在这种情况下，才将可以在       `ExecReload=`, `ExecStop=` …       之类的选项中使用 `$MAINPID` 变量。       

对于多进程的传统服务，当最初的进程成功退出后，将会剩余多个进程在持续运行，       因此，systemd 无法确定哪一个进程才是该服务的主进程。       在这种情况下，不可以使用 `$MAINPID` 变量。       然而，如果主进程会创建传统的PID文件，       那么应该将 `PIDFile=` 设为此PID文件的绝对路径，       以帮助 systemd 从该PID文件中读取主进程的PID，从而帮助确定该服务的主进程。       注意，守护进程必须在完成初始化之前写入PID文件，       否则可能会导致 systemd 读取失败(读取时文件不存在)。       

​       下面是一个单进程传统服务的示例：

```
[Unit]
Description=一个单进程传统服务

[Service]
Type=forking
ExecStart=/usr/sbin/my-simple-daemon -d

[Install]
WantedBy=multi-user.target
```

参见       [systemd.kill(5)](http://www.jinbuguo.com/systemd/systemd.kill.html#)       以了解如何结束服务进程。       





**例 5. DBus 服务**

对于需要在 D-Bus 系统总线上注册一个名字的服务，       应该使用 `Type=``dbus`       并且设置相应的 `BusName=` 值。       该服务不可以派生任何子进程。       一旦从 D-Bus 系统总线成功获取所需的名字，该服务即被视为初始化成功。       下面是一个典型的 D-Bus 服务：

```
[Unit]
Description=一个简单的 DBus 服务

[Service]
Type=dbus
BusName=org.example.simple-dbus-service
ExecStart=/usr/sbin/simple-dbus-service

[Install]
WantedBy=multi-user.target
```

​       对于*基于 D-Bus 启动*的服务来说，       不可以包含 "`[Install]`" 小节，       而是应该在对应的 D-Bus service 文件中设置 `SystemdService=` 选项，       例如(`/usr/share/dbus-1/system-services/org.example.simple-dbus-service.service`):

```
[D-BUS Service]
Name=org.example.simple-dbus-service
Exec=/usr/sbin/simple-dbus-service
User=root
SystemdService=simple-dbus-service.service
```

参见       [systemd.kill(5)](http://www.jinbuguo.com/systemd/systemd.kill.html#)       手册以了解如何结束服务进程。       





**例 6. 能够通知初始化已完成的服务**

`       Type=``simple`       类型的服务非常容易编写，       但是无法将"启动成功"的消息及时通知给 systemd        是一个重大缺陷。       `Type=``notify`       可以弥补该缺陷，       它支持将"启动成功"的消息及时通知给 systemd 。       下面是一个典型的例子：

```
[Unit]
Description=Simple notifying service

[Service]
Type=notify
ExecStart=/usr/sbin/simple-notifying-service

[Install]
WantedBy=multi-user.target
```

​       注意，该守护进程必须支持 systemd 通知协议，       否则 systemd 将会认为该服务一直处于"启动中"(activating)状态，并在超时后将其杀死。       关于如何支持该通知协议，参见       [sd_notify(3)](http://www.jinbuguo.com/systemd/sd_notify.html#)       手册。       

参见       [systemd.kill(5)](http://www.jinbuguo.com/systemd/systemd.kill.html#)       手册以了解如何结束服务进程。       





## 参见

​         [systemd(1)](http://www.jinbuguo.com/systemd/systemd.html#),         [systemctl(1)](http://www.jinbuguo.com/systemd/systemctl.html#),         [systemd.unit(5)](http://www.jinbuguo.com/systemd/systemd.unit.html#),         [systemd.exec(5)](http://www.jinbuguo.com/systemd/systemd.exec.html#),         [systemd.resource-control(5)](http://www.jinbuguo.com/systemd/systemd.resource-control.html#),         [systemd.kill(5)](http://www.jinbuguo.com/systemd/systemd.kill.html#),         [systemd.directives(7)](http://www.jinbuguo.com/systemd/systemd.directives.html#)       